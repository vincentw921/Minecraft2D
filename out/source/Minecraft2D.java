/* autogenerated by Processing revision 1282 on 2022-05-28 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Minecraft2D extends PApplet {

World world;
Player player;

boolean[] isPressed;

 public void setup(){
  /* size commented out by preprocessor */;
  world = new World();
  player = new Player();
  isPressed = new boolean[5];
}

 public void draw(){
  background(135,206,235);
  world.display();
  player.display();
  if(!(isPressed[0] && isPressed[1])){
    if (isPressed[0]) {
      player.moveX(-0.2f);
    }
    else if (isPressed[1]) {
      player.moveX(0.2f);
    }
  } 

  player.run();
}

 public void keyPressed() {
  if (key == 'a') {
    isPressed[0] = true;
  }
  if (key == 'd') {
    isPressed[1] = true;
  }
}

 public void keyReleased() {
  if (key == 'a') {
    isPressed[0] = false;
  }
  if (key == 'd') {
    isPressed[1] = false;
  }
}
public enum Blocks {
  TREE(new int[] {97, 59, 22}, 50), 
    LEAVES(new int[] {12, 174, 91}, 50), 
    GRASS(new int[] {86, 125, 70}, 50), 
    DIRT(new int[] {155, 118, 83}, 50), 
    SAND(new int[] {225, 217, 199}, 50), 
    STONE(new int[] {136, 140, 141}, 50), 
    DIORITE(new int[] {157, 191, 177}, 50), 
    GRANITE(new int[] {164, 135, 126}, 50), 
    IRON(new int[] {161, 157, 148}, 50), 
    COAL(new int[] {43, 45, 47}, 50), 
    GOLD(new int[] {212, 175, 55}, 50), 
    DIAMOND(new int[] {185, 242, 255}, 50), ;

  int[] col;
  float health;
  private Blocks(int[] col, float health) {
    this.col = col;
    this.health = health;
  }
}

final int SIZE = 50;

class Block {
  int c;
  float health;

  public Block(Blocks btype) {
    this.c = color(btype.col[0], btype.col[1], btype.col[2]);
    this.health = btype.health;
  }

  public void display(float x, float y) {
    fill(c);
    square(x * SIZE, y * SIZE, SIZE);
  }
  public boolean touching(float x, float y, float otherx, float othery) {
    return otherx > x && otherx < x + SIZE
      && othery > y && othery < y + SIZE;
  }

  public boolean touching(float x, float y, float otherx, float othery, float othervelx, float othervely) {
    float ox  = otherx + othervelx;
    float oy = othery + othervely;
    return touching(x, y, ox, oy) || touching(x, y, otherx, othery);
  }

  public void hit() {
  }
  private void isHit() {
  }
}
class Inventory {
  // kelvin do ur handy work :D
  final int rows = 5;
  final int cols = 6;   
  final int invenWidth = width - 300;
  final int invenHeight = 5 * invenWidth / 6;
  Block[][] inven;
  int border;
  int inside;

  Inventory(){
    border = color(150);
    inside = color(200, 200, 200, 200);
    inven = new Block[rows][cols];
  }

  public void display(){
    fill(inside);
    stroke(border);
    strokeWeight(6);
    int leftX = (width - invenWidth) / 2;
    int rightX = width - leftX;
    int topY = (height - invenHeight) / 2;
    int bottomY = height - topY;
    rect(leftX, topY, invenWidth, invenHeight, 23);

    stroke(border);
    strokeWeight(3);
    int cellWidth = (rightX - leftX) / (cols + 1);
    int cellHeight = (bottomY - topY) / (rows + 1);
    for(int r = 1; r < rows; r++){
      for(int c = 1; c < cols; c++){
        //vertical line
        line(leftX + c * cellWidth, topY, leftX + c * cellWidth, bottomY);
        //horizontal line
        line(leftX, topY + r * cellHeight, rightX, topY + r * cellHeight);
      }
    }
  }
    
}
class Player {
  final float FRICTION = 0.8f;
  final PVector GRAVITY = new PVector(0, -0.1f);
  final float MAX_HORIZONTAL_VEL = 5;
  boolean moving;

  PVector vel;
  PVector pos;
  
  PImage img;

  public Player() {
    this.pos = new PVector(width / 2, height / 2);
    this.vel = new PVector();
    img = loadImage("images/player.png");
    moving = false;
  }
  
  public void moveX(float xacc) {
    vel.add(new PVector(xacc, 0));
    if((xacc < 0 && vel.x > 0) || (xacc > 0 && vel.x < 0)) vel.set(vel.x * FRICTION, vel.y);
    moving = true;
  }

  public void run(){
    //vel.add(GRAVITY);
    vel.set(vel.x < 0 ? max(-MAX_HORIZONTAL_VEL, vel.x) : min(MAX_HORIZONTAL_VEL, vel.x), vel.y);
    if(!moving) vel.set(vel.x * FRICTION, vel.y);
    pos.add(vel);
    //println(vel.mag());
    moving = false;
  }
  
  public void display() {
    int w = 50;
    int h = 150;
    image(img, pos.x - w / 2, pos.y - h / 2, w, h);
  }
}
public enum Tools {
  
}

class Tool {
  
}
public enum Biome {
  SAND,
    GRASS,
    TREES;
}

class World {
  PVector screenPos;
  final int WORLD_WIDTH = 10000;
  final int WORLD_HEIGHT = 256;
  Block[][] blocks;
  Biome[] biome;

  public World() {
    this.screenPos = new PVector(WORLD_WIDTH / 2, 119);
    this.blocks = new Block[WORLD_WIDTH][WORLD_HEIGHT];
    int loc = 0;
    biome = new Biome[WORLD_WIDTH];
    while (loc < biome.length) {
      int add = (int)random(50, min(200, biome.length - loc));
      Biome b = Biome.values()[(int)random(Biome.values().length)];
      for (int i = loc; i < add; i++) {
        biome[i] = b;
      }
      loc += add;
    }

    for (int i = 0; i < blocks.length; i++) {
      for (int j = 0; j < blocks[0].length; j++) {
        blocks[i][j] = generateBlock(j, i);
      }
    }
    for (int i = 0; i < biome.length; i++) {
      if (biome[i] == Biome.TREES) {
        if (random(1) > 0.3f) {
          continue;
        }
        for (int h = 0; h < random(3,8); h++) {
          blocks[i][119 - h] = new Block(Blocks.TREE);
        }
      }
    }
  }
  
  public void display() {
    int ox = (int)(screenPos.x);
    int oy = (int)(screenPos.y);
    for (int i = 0; i < width / SIZE + 1; i++) {
      for (int j = 0; j < height / SIZE + 1; j++) {
        if (blocks[ox + i][oy + j] == null) {
          continue;
        }
        blocks[ox + i][oy + j].display(i,j);
      }
    }
  }

  private Block generateBlock(int h, int w) {
    if (h < 120) {
      return null;
    } else if (h >= 120 && h <= 130 && (biome[w] == Biome.GRASS || biome[w] == Biome.TREES)) {
      if (h == 120) {
        return new Block(Blocks.GRASS);
      } else {
        return new Block(Blocks.DIRT);
      }
    } else if (h >= 120 && h <= 130 && biome[w] == Biome.SAND) {
      return new Block(Blocks.SAND);
    } else if (h > 130 && h < 60) {
      float val = random(1);
      if (val > 0.5f) {
        return new Block(Blocks.STONE);
      } else if (val > 0.25f) {
        return new Block(Blocks.GRANITE);
      } else if (val > 0.1f) {
        return new Block(Blocks.DIORITE);
      } else if (val > 0.05f) {
        return new Block(Blocks.COAL);
      } else {
        return new Block(Blocks.IRON);
      }
    } else if (h >= 60 && h < 35) {
      float val = random(1);
      if (val > 0.5f) {
        return new Block(Blocks.STONE);
      } else if (val > 0.25f) {
        return new Block(Blocks.GRANITE);
      } else if (val > 0.15f) {
        return new Block(Blocks.DIORITE);
      } else if (val > 0.1f) {
        return new Block(Blocks.COAL);
      } else if (val > 0.5f) {
        return new Block(Blocks.IRON);
      } else {
        return new Block(Blocks.GOLD);
      }
    } else {
      float val = random(1);
      if (val > 0.5f) {
        return new Block(Blocks.STONE);
      } else if (val > 0.35f) {
        return new Block(Blocks.GRANITE);
      } else if (val > 0.2f) {
        return new Block(Blocks.DIORITE);
      } else if (val > 0.15f) {
        return new Block(Blocks.GOLD);
      } else if (val > 0.1f) {
        return new Block(Blocks.IRON);
      } else if (val > 0.05f) {
        return new Block(Blocks.COAL);
      } else {
        return new Block(Blocks.DIAMOND);
      }
    }
  }
}


  public void settings() { size(1000, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Minecraft2D" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
