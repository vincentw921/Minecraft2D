/* autogenerated by Processing revision 1282 on 2022-06-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Minecraft2D extends PApplet {

DeadBlocks deadBlocks = new DeadBlocks();
World world;
Player player;
Inventory inventory;

boolean worldLoaded = false;
boolean enterPressed = false;
String saveAs = "";
Button play;

boolean[] isPressed;
boolean[] mouse;
boolean autosave;

 public void setup() {  
  /* size commented out by preprocessor */;
  int buttonw = 800;
  int buttonh = 300;
  play = new Button(width / 2 - buttonw / 2, 100, buttonw, buttonh, color(100), color(0), "Play Now!");
  if (createInput("saves/" + saveAs) == null) {
    world = new World();
    player = new Player();
    inventory = new Inventory();
    isPressed = new boolean[5];
    mouse = new boolean[2];
    return;
  }
  Table t = loadTable("saves/" + saveAs);
  world = new World();
  TableRow worldLocation = t.getRow(0);
  world.screenPos.x = worldLocation.getFloat(0);
  world.screenPos.y = worldLocation.getFloat(1);
  player = new Player();
  TableRow playerPos = t.getRow(1);
  player.pos.x = playerPos.getFloat(0);
  player.pos.y = playerPos.getFloat(1);
  TableRow btype = t.getRow(2);
  TableRow blockHealths = t.getRow(3);
  for (int i = 0; i < world.WORLD_WIDTH * world.WORLD_HEIGHT; i++) {
    if (btype.getString(i).equals("null")) {
      world.blocks[i % world.WORLD_WIDTH][i / world.WORLD_WIDTH] = null;
      continue;
    }
    world.blocks[i % world.WORLD_WIDTH][i / world.WORLD_WIDTH] = new Block(Blocks.valueOf(btype.getString(i)));
    world.blocks[i % world.WORLD_WIDTH][i / world.WORLD_WIDTH].health = blockHealths.getFloat(i);
  }
  inventory = new Inventory();
  TableRow toolName = t.getRow(4);
  TableRow damage = t.getRow(5);
  TableRow health = t.getRow(6);
  TableRow Btype = t.getRow(7);
  TableRow amount = t.getRow(8);

  for (int i = 0; i < inventory.rows * inventory.cols; i++) {
    if (toolName.getString(i).equals("Inven Null")) {
      continue;
    }
    if (Btype.getString(i).equals("null")) {
      inventory.inven[i % inventory.rows][i / inventory.rows] = new Item(new Tool(toolName.getString(i), health.getInt(i), damage.getInt(i)));
    } else {
      Block temp = new Block(Blocks.valueOf(Btype.getString(i)));
      inventory.inven[i % inventory.rows][i / inventory.rows] = new Item(temp, amount.getInt(i));
    }
  }
  isPressed = new boolean[5];
  mouse = new boolean[2];
  autosave = false;
  println("AUTOSAVE : " + (autosave ? "ON" : "OFF"));
}

 public void draw() {
  if (!worldLoaded) {
    background(0);
    play.display();
    displayTextBox(width / 2 - 800 / 2, 500);
    if (play.beenPressed || enterPressed) {
      enterPressed = false;
      if (saveAs.length() <= 0) {
        println("Please enter a valid file name");
        return;
      }
      if (!saveAs.contains(".csv")) {
        saveAs += ".csv";
      }
      worldLoaded = true;
      setup();
    }
    return;
  }
  background(135, 206, 235);
  world.display();
  deadBlocks.display();
  deadBlocks.checkPlayerTouching();
  player.display();
  if(!isPressed[2]){
    if (!(isPressed[0] && isPressed[1])) {
      if (isPressed[0] && player.notHasLeft(-0.01f)) {
        player.moveX(-0.01f);
      } else if (isPressed[1] && player.notHasRight(0.01f)) {
        player.moveX(0.01f);
      }
    }
    if (isPressed[3]) {
      if (player.hasGround(-0.2f)) {
        player.vel.set(player.vel.x, 0);
        player.vel.add(0, -0.2f);
      }
    }
  }
  
  if (isPressed[2]) {
    inventory.display();
  } else {
    inventory.selecting = false;
    inventory.selected = new int[]{0, 0};
  }

  if (mouse[0] && !isPressed[2]) {
    world.checkHit();
  }

  player.run();
  if(!autosave){
    fill(255, 100, 50, 150);
  } else {
    fill(100, 255, 50, 150);
  }
  stroke(0);
  strokeWeight(1);
  rect(width - 220, height - 50, 220, 50, 10);
  fill(0);
  textSize(15);
  text("press space to toggle autosave", width - 100, height - 30);

}

 public void keyPressed() {
  if (!worldLoaded) {
    if (key == '\b') {
      saveAs = saveAs.substring(0, max(0, saveAs.length() - 1));
    } else if (key == '\n') {
      enterPressed = true;
    } else {
      saveAs += key;
    }
    return;
  }
  if (key == 'a') {
    isPressed[0] = true;
  }
  if (key == 'd') {
    isPressed[1] = true;
  }
  if (key == 'w') {
    isPressed[3] = true;
  }
  
  
  
}

 public void keyReleased() {
  if (key == 'a') {
    isPressed[0] = false;
  }
  if (key == 'd') {
    isPressed[1] = false;
  }
  if (key == 'w') {
    isPressed[3] = false;
  }
  if (key == 'g') {
    println(inventory.selected[0] + " " + inventory.selected[1] + " " + inventory.selecting);
  }
  if(key == ' '){
    autosave = !autosave;
  }
  if (key == 'e') {
    isPressed[2] = !isPressed[2];
  }
}

 public void mousePressed() {
  if (!worldLoaded) {
    play.checkPress(mouseX, mouseY);
    return;
  }
  if (mouseButton == LEFT) {
    mouse[0] = true;
  }
  if (mouseButton == RIGHT) {
    mouse[1] = true;
  }
}

 public void mouseReleased() {
  if (mouseButton == LEFT) {
    mouse[0] = false;
  }
  if (mouseButton == RIGHT) {
    mouse[1] = false;
  }
  if(isPressed[2]){
    inventory.setSelected(mouseX, mouseY);
  }
}

 public void exit() {
  if(!autosave) return;
  Table table = new Table();

  table.addRow(new Float[] {world.screenPos.x, world.screenPos.y});
  table.addRow(new Float[] {player.pos.x, player.pos.y});

  String[] btype = new String[world.blocks[0].length * world.blocks.length];
  Float[] healths = new Float[world.blocks[0].length * world.blocks.length];
  for (int i = 0; i < world.blocks.length; i++) {
    for (int j = 0; j < world.blocks[0].length; j++) {
      if (world.blocks[i][j] == null) {
        btype[i + j * world.blocks.length] = "null";
        continue;
      }
      healths[i + j * world.blocks.length] = world.blocks[i][j].health;
      btype[i + j * world.blocks.length] = world.blocks[i][j].btype.toString();
    }
  }
  table.addRow(btype);
  table.addRow(healths);
  String[] toolName = new String[inventory.inven.length * inventory.inven[0].length];
  Integer[] damage = new Integer[inventory.inven.length * inventory.inven[0].length];
  Float[] health = new Float[inventory.inven.length * inventory.inven[0].length];
  String[] Btype = new String[inventory.inven.length * inventory.inven[0].length];
  Integer[] amount = new Integer[inventory.inven.length * inventory.inven[0].length];

  for (int i = 0; i < inventory.inven.length; i++) {
    for (int j = 0; j < inventory.inven[0].length; j++) {
      if (inventory.inven[i][j] == null) {
        toolName[i + j * inventory.inven.length] = "Inven Null";
        continue;
      }
      if (inventory.inven[i][j].tool == null) {
        health[i + j * inventory.inven.length] = inventory.inven[i][j].block.health;
        Btype[i + j * inventory.inven.length] = inventory.inven[i][j].block.btype.toString();
        amount[i + j * inventory.inven.length] = inventory.inven[i][j].amount;
        continue;
      }
      Btype[i + j * inventory.inven.length] = "null";

      toolName[i + j * inventory.inven.length] = inventory.inven[i][j].tool.name;
      health[i + j * inventory.inven.length] = Float.valueOf(inventory.inven[i][j].tool.health);
      damage[i + j * inventory.inven.length] = inventory.inven[i][j].tool.damage;
    }
  }
  table.addRow(toolName);
  table.addRow(damage);
  table.addRow(health);
  table.addRow(Btype);
  table.addRow(amount);
  saveTable(table, "saves/" + saveAs);
  dispose();
}
public enum Blocks {
  TREE(new int[] {97, 59, 22}, 50),
    LEAVES(new int[] {12, 174, 91}, 50),
    WOOD(new int[] {150, 111, 51}, 50),
    GRASS(new int[] {86, 125, 70}, 50),
    DIRT(new int[] {155, 118, 83}, 50),
    SAND(new int[] {225, 217, 199}, 50),
    STONE(new int[] {136, 140, 141}, 50),
    DIORITE(new int[] {157, 191, 177}, 50),
    GRANITE(new int[] {164, 135, 126}, 50),
    IRON(new int[] {161, 157, 148}, 50),
    COAL(new int[] {43, 45, 47}, 50),
    GOLD(new int[] {212, 175, 55}, 50),
    DIAMOND(new int[] {185, 242, 255}, 50),
    BEDROCK(new int[] {0, 0, 0}, 10000);

  int[] col;
  float health;
  private Blocks(int[] col, float health) {
    this.col = col;
    this.health = health;
  }
}

final int SIZE = 50;
final int SIZE_DEAD = 10;

class Block {
  boolean isDead;
  float deadTimer = 100 * 60 * 30;

  Blocks btype;
  int c;
  int[] car;
  float health;

  float x, y;

  public Block(Blocks btype) {
    this.btype = btype;
    this.c = color(btype.col[0], btype.col[1], btype.col[2]);
    this.car = btype.col;
    this.health = btype.health;
    this.x = 0;
    this.y = 0;
  }

  public Block(int[] c, float health, int posX, int posY) {
    this.x = posX;
    this.y = posY;
    this.c = color(c[0], c[1], c[2]);
    this.car = c;
    this.health = health;
  }

  public void display(float x, float y) {
    if (isDead) {
      deadTimer--;
      stroke(0);
      strokeWeight(1);
      fill(c);
      square(this.x * SIZE, this.y * SIZE, SIZE_DEAD);
    }
    stroke(0);
    strokeWeight(1);
    fill(c);
    square(x * SIZE, y * SIZE, SIZE);
  }
  public void decreaseY() {
    if (world.blocks[(int)x][(int)y] == null) {
      y += 0.01f;
    }
  }
  public void display(float x, float y, int size) {
    stroke(0);
    strokeWeight(1);
    fill(c);
    square(x, y, size);
  }
  
  public void display(int size) {
    float bx = x - world.screenPos.x;
    float by = y - world.screenPos.y;
    stroke(0);
    strokeWeight(1);
    fill(c);
    square(bx * 50 + 50 / 2 - 10, by * 50 - 20, size);
  }
  
  public boolean touching(float x, float y) {
    float bx = x - world.screenPos.x + (int)world.screenPos.x;
    float by = y - world.screenPos.y + (int)world.screenPos.y;
    return x >= bx - 1 && x <= bx + SIZE + 1
      && y >= by - 1 && y <= by + SIZE + 1;
  }
  public boolean touching(float x, float y, float SIZE) {
    float bx = (this.x - world.screenPos.x) * 50 + 50 / 2 - 10;
    float by = (this.y - world.screenPos.y) * 50;
    return x >= bx - 1 && x <= bx + SIZE + 1
      && y >= by - 1 && y <= by + SIZE + 1;
  }
  
  public PVector getPosition() {
    float bx = x - world.screenPos.x + (int)world.screenPos.x;
    float by = y - world.screenPos.y + (int)world.screenPos.y;
    
    return new PVector(bx, by);
  } 
  
  public boolean playerTouchingDead(float x, float y, float w, float h) {
    return touching(x, y, 20) || touching(x + w, y, 20) || touching(x, y + h, 20) || touching (x + w, y + h, 20);
  }

  public boolean playerTouching(float x, float y, float w, float h) {
    return touching(x, y) || touching(x + w, y) || touching(x, y + h) || touching (x + w, y + h) || touching(x,y + h/3) || touching(x + w, y + h/3) || touching(x, y + 2 * h / 3) || touching(x + w, y + 2 * h / 3)
     || touching(x, y + 7 * h / 10) || touching(x + w, y + 7 * h / 10) || touching(x, y + 8 * h / 10) || touching(x + w, y + 8 * h / 10);
  }
  public float getXSpeedUntilTouching(float x, float w, boolean movingLeft) {
    float bx = x - world.screenPos.x + (int)world.screenPos.x;
    if (movingLeft) {
      return x - bx + SIZE;
    } else {
      return bx - (x + w);
    }
  }
  
  public float getYSpeedUntilTouching(float y, float h, boolean movingUp) {
    float by = y - world.screenPos.y + (int)world.screenPos.y;
    if (y + h > by) {
      movingUp = true;
    }
    if (movingUp) {
      return y - by + SIZE;
    } else {
      return by - (y + h);
    }
  }

  public void hit() {
    if (btype == Blocks.BEDROCK) {
      return;
    }
    this.health -= 50;
  }
}
public enum Crafts {
  PLANK(Blocks.WOOD, 4, Blocks.TREE),
  STICKS(Tools.STICK, 4, Blocks.WOOD, Blocks.WOOD),
  WOOD_PICKAXE(Tools.PICKAXE, Type.WOOD, new Blocks[] {Blocks.WOOD, Blocks.WOOD, Blocks.WOOD}, new Tools[] {Tools.STICK, Tools.STICK});
  
  Blocks[] blockRequirements;
  Tools[] toolRequirements;
  
  Blocks blockResult;
  Tools toolResult;
  Type toolType;
  
  int resultAmount;
  
  private Crafts(Blocks result, int amount, Blocks... requirements) {
    this.blockResult = result;
    this.blockRequirements = requirements;
    this.resultAmount = amount;
  }
  private Crafts(Tools result, int amount, Blocks... requirements) {
    this.toolResult = result;
    this.resultAmount = amount;
    this.blockRequirements = requirements;
  }
  private Crafts(Tools result, Type toolType, Blocks[] requirements, Tools[] toolRequirements) {
    this.toolRequirements = toolRequirements;
    this.blockRequirements = requirements;
    this.toolType = toolType;
    this.toolResult = result;
  }
}

class CraftingInventory {
  
}

class CraftingTable {
  
}
class DeadBlocks {
  HashMap<Block, Integer> dbs = new HashMap<Block, Integer>();

   public void display() {
    for (Block b : dbs.keySet()) {
      b.decreaseY();
      if (b.x > world.screenPos.x && b.x < world.screenPos.x + width / SIZE + 1
        && b.y > world.screenPos.y && b.y < world.screenPos.y + height / SIZE + 1) {
        b.display(20);
      }
    }
  }

   public void addBlock(Block newBlock) {
    for (Block b : dbs.keySet()) {
      if (newBlock.btype == b.btype && b.x > world.screenPos.x && b.x < world.screenPos.x + width / SIZE + 1 && b.y > world.screenPos.y && b.y < world.screenPos.y + height / SIZE + 1) {
        int temp = dbs.get(b);
        if (temp + 1 > 64) {
          break;
        }
        dbs.put(b, temp + 1);
        return;
      }
    }
    dbs.put(newBlock, 1);
  }

   public void checkPlayerTouching() {
    if (inventory.isFull()) {
      return;
    }
    for (Block b : dbs.keySet()) {
      b.decreaseY();
      if (b.x > world.screenPos.x && b.x < world.screenPos.x + width / SIZE + 1
        && b.y > world.screenPos.y && b.y < world.screenPos.y + height / SIZE + 1) {
        boolean x = b.playerTouchingDead(player.pos.x, player.pos.y, player.WIDTH, player.HEIGHT);
        if (x) {
          inventory.addItem(new Item(b, dbs.get(b)));
          dbs.remove(b);
        }
        return;
      }
    }
  }
}
class Inventory {
  final int rows = 5;
  final int cols = 6;
  final int invenWidth = width - 300;
  final int invenHeight = 5 * invenWidth / 6;
  Item[][] inven;
  int[] selected;
  int border;
  int inside;
  boolean selecting;

  int leftX = (width - invenWidth) / 2;
  int rightX = width - leftX;
  int topY = (height - invenHeight) / 2;
  int bottomY = height - topY;
  int cellWidth = (rightX - leftX) / cols;
  int cellHeight = (bottomY - topY) / rows;

  public Inventory() {
    border = color(150);
    inside = color(200, 200, 200, 200);
    inven = new Item[rows][cols];
    selected = new int[2];
    //addItem(new Item(new Block(Blocks.TREE), 5));
    //inven[0][0] = new Item(new Block(Blocks.TREE), 5);
  }

  public void display() {
    fill(inside);
    stroke(border);
    strokeWeight(6);
    
    rect(leftX, topY, invenWidth, invenHeight, 23);

    stroke(border);
    strokeWeight(3);
    if(selecting){
      fill(color(50, 255, 50, 100));
      noStroke();
      //if(selected[0] == 0 && selected[1] == 0){
      rect(leftX + (selected[1]) * cellWidth, topY + (selected[0]) * cellHeight, cellWidth, cellHeight);
      //}
    }
    for (int r = 1; r < rows + 1; r++) {
      for (int c = 1; c < cols + 1; c++) {
        stroke(border);
        strokeWeight(3);
        //vertical line
        line(leftX + c * cellWidth, topY, leftX + c * cellWidth, bottomY);
        //horizontal line
        line(leftX, topY + r * cellHeight, rightX, topY + r * cellHeight);
        if (inven[r-1][c-1] == null) {
          continue;
        }
        inven[r-1][c-1].display(leftX + (c-1) * cellWidth, topY + (r-1) * cellHeight, (bottomY - topY) / rows);
      }
    }
  }

  public void addItem(Item item) {
    int curItem; 
    for (curItem = 0; curItem < inven.length * inven[0].length; curItem++) {
      if (inven[curItem / cols][curItem % cols] == null) {
        break;
      }
    }
    if (item.block == null) {
      inven[curItem / cols][curItem % cols] = item;
    } else {
      boolean hasblockalready = false;
      for (int items = 0; items < curItem; items++) {
        if (inven[items / cols][items % cols].block != null
          && inven[items / cols][items % cols].block.btype == item.block.btype) {
          hasblockalready = true;
          inven[items / cols][items % cols].amount += item.amount;
          if (inven[items / cols][items % cols].amount > 64) {
            inven[items / cols][items % cols].amount = 64;
            addItem(new Item(inven[items / cols][items % cols].block, inven[items / cols][items % cols].amount - 64));
          }
        }
      }
      if (!hasblockalready) {
        inven[curItem / cols][curItem % cols] = item;
      }
    }
  }

  public boolean isFull() {
    for (int i = 0; i < inven.length; i++) {
      for (int j = 0; j < inven[0].length; j++) {
        if (inven[i][j] == null) return false;
      }
    }
    return true;
  }

  public void remove(int pos) {
    inven[pos % cols][pos / cols] = null;
  }

  public void move(int pos, int otherPos) {
    Item temp = null;
    if (inven[otherPos % cols][otherPos / cols] != null) {
      temp = inven[otherPos % cols][otherPos / cols];
    }
    inven[otherPos % cols][otherPos / cols] = inven[pos % cols][pos / cols];
    inven[pos % cols][pos / cols] = temp;
  }
  
  public String print() {
    String s = "";
    for (int i = 0; i < inven.length * inven[0].length; i++) {
      //println(i);
      if (inven[i / cols][i % cols] == null) {
        s += ", null";
        continue;
      }
      s += ", " + inven[i / cols][i % cols].toString();
    }
    return s;
  }

  public void setSelected(int x, int y) {
    if(selecting){
      
      int[] temp = getCell(x, y);
      selecting = false;
      if(temp[0] != -1 && temp[1] != -1){
        //swap selected[0], selected[1] with cells at x, y
        Item tempItem = inven[selected[0]][selected[1]];
        inven[selected[0]][selected[1]] = inven[temp[0]][temp[1]];
        inven[temp[0]][temp[1]] = tempItem;
      } 
      selected = new int[]{-1, -1};

    } else {
      selected = getCell(x, y);
      if(selected[0] != -1 && selected[1] != -1){
        selecting = true;
      }
    }
  }
  private int[] getCell(int x, int y) {
    for(int row = 1; row <= rows; row++){
      for(int col = 1; col <= cols; col++){
        if(x < col * cellWidth + leftX && x > col * cellWidth + leftX - cellWidth && y < row * cellHeight + topY && y > row * cellHeight + topY - cellHeight){
          return new int[]{row - 1, col - 1};
        }
      }
    }
    return new int[]{-1, -1};
  }
}
class Item {
  Block block;
  Tool tool;
  
  int amount;
  
  public Item(Block block, int amount) {
    this.block = block;
    this.amount = amount;
  }
  
  public Item(Tool tool) {
    this.tool = tool;
  }
  
  public void display(int x, int y, int size) {
    if (block == null) {
      tool.display(x,y,size - 20);
    } else {
      block.display(x,y,size - 20);
      textSize(size);
      fill(0);
      text(amount,x + size / 2, y + size - 25);
    }
  }
  public String toString() {
    if (block == null && tool != null) {
      return "TOOL";
    } else if (tool == null && block != null) {
      return "BLOCK";
    }
    return "null";
  }
  //with block.btype.toString()
  //, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,
  //with BLOCK
  //, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,, null,
}
final PVector GRAVITY = new PVector(0, 0.01f);

class Player {
  final float FRICTION = 0.8f;
  final float MAX_HORIZONTAL_VEL = 0.15f;


  boolean moving;

  final int WIDTH = 50;
  final int HEIGHT = 150;
  PVector vel;
  PVector pos;

  PImage img;

  public Player() {
    this.pos = new PVector(width / 2 - (WIDTH) + SIZE / 2, height / 2 + 25 - (HEIGHT)/ 2);
    this.vel = new PVector();
    img = loadImage("images/player.png");
    moving = false;
  }

  public void moveX(float xacc) {
    vel.add(new PVector(xacc, 0));
    if ((xacc < 0 && vel.x > 0) || (xacc > 0 && vel.x < 0)) vel.set(vel.x * FRICTION, vel.y);
    moving = true;
  }

  public boolean hasGround(float vely) {
    return world.blocks[(int)world.screenPos.x + width / 2 / SIZE][12 + (int)world.screenPos.y] != null &&
      world.blocks[(int)world.screenPos.x + width / 2 / SIZE][12 + (int)world.screenPos.y].playerTouching(pos.x, pos.y + vely, WIDTH, HEIGHT);
  }
  public boolean hasTopBlock(float vely) {
    return world.blocks[(int)world.screenPos.x + width / 2 / SIZE][9 + (int)world.screenPos.y] != null &&
      world.blocks[(int)world.screenPos.x + width / 2 / SIZE][9 + (int)world.screenPos.y].playerTouching(pos.x, pos.y + vely, WIDTH, HEIGHT);
  }
  public boolean notHasLeft(float velx) {
    boolean firstBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][11 + (int)world.screenPos.y] != null;
    boolean secondBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][10 + (int)world.screenPos.y] != null;
    boolean thirdBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][9 + (int)world.screenPos.y] != null;
    return !(firstBlock && world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][11 + (int)world.screenPos.y].playerTouching(pos.x + velx, pos.y, WIDTH, HEIGHT))
      && !(secondBlock && world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][10 + (int)world.screenPos.y].playerTouching(pos.x + velx, pos.y, WIDTH, HEIGHT))
      && !(thirdBlock && world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][9 + (int)world.screenPos.y].playerTouching(pos.x + velx, pos.y, WIDTH, HEIGHT));
  }
  public boolean notHasRight(float velx) {
    boolean firstBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][11 + (int)world.screenPos.y] != null;
    boolean secondBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][10 + (int)world.screenPos.y] != null;
    boolean thirdBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][9 + (int)world.screenPos.y] != null;
    return !(firstBlock && world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][11 + (int)world.screenPos.y].playerTouching(pos.x + velx, pos.y, WIDTH, HEIGHT))
      && !(secondBlock && world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][10 + (int)world.screenPos.y].playerTouching(pos.x + velx, pos.y, WIDTH, HEIGHT))
      && !(thirdBlock && world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][9 + (int)world.screenPos.y].playerTouching(pos.x + velx, pos.y, WIDTH, HEIGHT));
  }
  //public List<Block> getNeighboringBlocks() {
  //}

  //private Block getBlock(int dx, int dy) {
  //PVector pos = new PVector((int)pos.x
  //}

  public void run() {
    if (hasTopBlock(vel.y)) {
      vel.y = 0;
    }
    if (!hasGround(vel.y)) {
      int curNull = (12 + (int)world.screenPos.y);
      while (world.blocks[(int)world.screenPos.x + width / 2 / SIZE][curNull] == null) {
        curNull++;
      }
      vel.set(vel.x, min(vel.y + GRAVITY.y, world.blocks[(int)world.screenPos.x + width / 2 / SIZE][curNull].getYSpeedUntilTouching(pos.x, pos.y, false)));
    }
    if (vel.x < 0) {
      if (!notHasLeft(vel.x)) {
        boolean firstBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][11 + (int)world.screenPos.y] != null;
        boolean secondBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][10 + (int)world.screenPos.y] != null;
        boolean thirdBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][9 + (int)world.screenPos.y] != null;
        float dist = 10000;
        if (firstBlock) {
          dist = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][11 + (int)world.screenPos.y].getXSpeedUntilTouching(pos.x, WIDTH, true);
        } else if (secondBlock) {
          dist = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][10 + (int)world.screenPos.y].getXSpeedUntilTouching(pos.x, WIDTH, true);
        } else if (thirdBlock) {
          dist = world.blocks[(int)world.screenPos.x + width / 2 / SIZE - 1][9 + (int)world.screenPos.y].getXSpeedUntilTouching(pos.x, WIDTH, true);
        }
        vel.set(min(vel.x, dist), vel.y);
      }
    } else {
      if (!notHasRight(vel.y)) {
        boolean firstBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][11 + (int)world.screenPos.y] != null;
        boolean secondBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][10 + (int)world.screenPos.y] != null;
        boolean thirdBlock = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][9 + (int)world.screenPos.y] != null;
        float dist = 10000;
        if (firstBlock) {
          dist = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][11 + (int)world.screenPos.y].getXSpeedUntilTouching(pos.x, WIDTH, true);
        } else if (secondBlock) {
          dist = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][10 + (int)world.screenPos.y].getXSpeedUntilTouching(pos.x, WIDTH, true);
        } else if (thirdBlock) {
          dist = world.blocks[(int)world.screenPos.x + width / 2 / SIZE + 1][9 + (int)world.screenPos.y].getXSpeedUntilTouching(pos.x, WIDTH, true);
        }
        vel.set(min(vel.x, dist), vel.y);
      }
    }
    vel.set(vel.x < 0 ? max(-MAX_HORIZONTAL_VEL, vel.x) : min(MAX_HORIZONTAL_VEL, vel.x), vel.y);
    if (!moving) vel.set(vel.x * FRICTION, vel.y);
    world.screenPos.add(vel);
    if (hasGround(vel.y)) {
      vel.set(vel.x, 0);
    }
    //println(vel.mag());
    moving = false;
  }

  public void display() {
    image(img, pos.x, pos.y, (WIDTH + (50 - WIDTH)), HEIGHT);
    PVector end = new PVector(mouseX, mouseY);
    PVector start = new PVector(pos.x + (WIDTH + (50 - WIDTH)) / 2, pos.y + HEIGHT / 2);
    end.sub(start);
    if (end.mag() > 2 * SIZE) {
      end.mult(1 / end.mag() * 3.2f * SIZE);
    }
    end.add(start);
    strokeWeight(20);
    stroke(color(100, 100, 100, 200));
    line(start.x, start.y, end.x, end.y);
  }
}
 public void displayTextBox(int x, int y) {
  fill(100);
  imageMode(CORNER);
  rect(x,y,800,500,100);
  textAlign(CENTER);
  textSize(300);
  fill(255);
  text(saveAs, x + 800 / 2, y + 500 / 2);
}
public enum Tools {
  PICKAXE("pick"),
  AXE("axe"),
  SHOVEL("shovel"),
  SWORD("sword"),
  STICK("stick");
  
  String name;
  private Tools(String name) {
    this.name = name;
  }
}

public enum Type {
  WOOD("wood", 10, 5),
  STONE("stone", 10, 5),
  IRON("iron", 10, 5),
  GOLD("gold", 10, 5),
  DIAMOND("diamond", 10, 5);
  
  String name;
  int damage;
  int health;
  private Type(String name, int damage, int health) {
    this.name = name;
    this.damage = damage;
    this.health = health;
  }
}

class Tool {
  final int IMAGE_SIZE = 50;
  final PVector pos = new PVector(width / 2, height / 2 + 25 + 75);;
  String name;
  
  int damage;
  int health;
  PImage image;
  public Tool(Tools tool, Type material) {
    this.name = tool.name + material.name;
    this.image = loadImage(tool.name + material.name + ".png");
    this.health = material.health;
    this.damage = material.damage;
  }
  
  public Tool(String img, int health, int damage) {
    this.name = img;
    this.image = loadImage(img);
    this.damage = damage;
    this.health = health;
  }
  
  public void display() {
    image(image, pos.x, pos.y, IMAGE_SIZE, IMAGE_SIZE);
  }
  
  public void display(int x, int y, int size) {
    image(image, x, y, size, size);
  }
}
class World {
  PVector screenPos;
  final int WORLD_WIDTH = 10000;
  final int WORLD_HEIGHT = 256;
  Block[][] blocks;

  public World() {
    this.screenPos = new PVector(WORLD_WIDTH / 2, 108);
    this.blocks = new Block[WORLD_WIDTH][WORLD_HEIGHT];

    for (int i = 0; i < blocks.length; i++) {
      for (int j = 0; j < blocks[0].length; j++) {
        blocks[i][j] = generateBlock(j);
        if (blocks[i][j] == null) continue;
        blocks[i][j].x = i;
        blocks[i][j].y = j;
      }
    }
    int prevTree = 3;
    for (int i = 0; i < blocks.length; i++) {
      if (i == WORLD_WIDTH / 2 - 1 || i == WORLD_WIDTH / 2 || i == WORLD_WIDTH / 2 + 1) {
        continue;
      }
      if (random(1) > 0.1f || prevTree > 0) {
        prevTree--;
        continue;
      }
      prevTree = 3;
      int maxH = (int)random(3, 8);
      for (int h = 0; h < maxH; h++) {
        blocks[i][119 - h] = new Block(Blocks.TREE);
        blocks[i][119 - h].x = i;
        blocks[i][119 - h].y = 119-h;
      }
      blocks[i][119 - maxH] = new Block(Blocks.LEAVES);
      blocks[i][119 - maxH].x = i;
      blocks[i][119 - maxH].y = 119-maxH;
      blocks[i-1][119-maxH] = new Block(Blocks.LEAVES);
      blocks[i-1][119 - maxH].x = i-1;
      blocks[i-1][119 - maxH].y = 119-maxH;
      blocks[i-1][119-maxH + 1] = new Block(Blocks.LEAVES);
      blocks[i-1][119 - maxH + 1].x = i-1;
      blocks[i-1][119 - maxH + 1].y = 119-maxH + 1;
      if (i + 1 < blocks.length) {
        blocks[i+1][119-maxH] = new Block(Blocks.LEAVES);
        blocks[i+1][119-maxH + 1] = new Block(Blocks.LEAVES);
        blocks[i+1][119-maxH].x = i + 1;
        blocks[i+1][119-maxH].y = 119 - maxH;
        blocks[i+1][119-maxH + 1].x = i + 1;
        blocks[i+1][119-maxH + 1].y = 119 - maxH + 1;
      }
    }

    for (int i = 0; i < blocks.length; i++) {
      blocks[i][0] = new Block(Blocks.BEDROCK);
      blocks[i][blocks[0].length - 1] = new Block(Blocks.BEDROCK);
    }
    for (int j = 0; j < blocks[0].length; j++) {
      blocks[0][j] = new Block(Blocks.BEDROCK);
      blocks[blocks.length - 1][j] = new Block(Blocks.BEDROCK);
    }
  }

  public boolean hasPosition(int col, int row) {
    return col >= 0 && col < blocks.length && row >= 0 && row < blocks[0].length;
  }

  public boolean hasBlock(int col, int row) {
    if (!hasPosition(col, row)) return false;
    return blocks[col][row] != null;
  }

  public Block getBlock(int col, int row) {
    if (!hasPosition(col, row)) return null;
    return blocks[col][row];
  }

  public void display() {
    float ox = screenPos.x;
    float oy = screenPos.y;
    for (int i = 0; i < width / SIZE + 1; i++) {
      for (int j = 0; j < height / SIZE + 1; j++) {
        if ((int)ox + i >= blocks.length || (int)oy + j >= blocks[0].length
          || (int)ox + i < 0 || (int)oy + j < 0) {
          continue;
        }
        if (blocks[(int)ox + i][(int)oy + j] == null) {
          continue;
        }
        blocks[(int)ox + i][(int)oy + j].display(i - ox + (int)ox, j - oy + (int)oy);
      }
    }
  }


  public void checkHit() {
    PVector end = new PVector(mouseX, mouseY);
    PVector start = new PVector(player.pos.x + player.WIDTH / 2, player.pos.y + player.HEIGHT / 2);
    end.sub(start);
    if (end.mag() > 3 * SIZE) {
      end.mult(1 / end.mag() * 3 * SIZE);
    }
    end.add(start);

    int x = (int)end.x / SIZE + (int)screenPos.x;
    int y = (int)end.y / SIZE + (int)screenPos.y;
    if (x >= blocks.length || x < 0 || y >= blocks[0].length || y < 0 ||
      blocks[x][y] == null) {
      return;
    }
    blocks[x][y].hit();
    if (blocks[x][y].health <= 0) {
      blocks[x][y].isDead = true;
      deadBlocks.addBlock(blocks[x][y]);
      blocks[x][y] = null;
    }
  }

  private Block generateBlock(int h) {
    if (h < 120) {
      return null;
    } else if (h >= 120 && h <= 125) {
      if (h == 120) {
        return new Block(Blocks.GRASS);
      } else {
        return new Block(Blocks.DIRT);
      }
    } else if (h > 125 && h < 150) {
      float val = random(1);
      if (val > 0.5f) {
        return new Block(Blocks.STONE);
      } else if (val > 0.25f) {
        return new Block(Blocks.GRANITE);
      } else if (val > 0.1f) {
        return new Block(Blocks.DIORITE);
      } else if (val > 0.05f) {
        return new Block(Blocks.COAL);
      } else {
        return new Block(Blocks.IRON);
      }
    } else if (h >= 150 && h < 200) {
      float val = random(1);
      if (val > 0.5f) {
        return new Block(Blocks.STONE);
      } else if (val > 0.25f) {
        return new Block(Blocks.GRANITE);
      } else if (val > 0.15f) {
        return new Block(Blocks.DIORITE);
      } else if (val > 0.1f) {
        return new Block(Blocks.COAL);
      } else if (val > 0.5f) {
        return new Block(Blocks.IRON);
      } else {
        return new Block(Blocks.GOLD);
      }
    } else {
      float val = random(1);
      if (val > 0.5f) {
        return new Block(Blocks.STONE);
      } else if (val > 0.35f) {
        return new Block(Blocks.GRANITE);
      } else if (val > 0.2f) {
        return new Block(Blocks.DIORITE);
      } else if (val > 0.15f) {
        return new Block(Blocks.GOLD);
      } else if (val > 0.1f) {
        return new Block(Blocks.IRON);
      } else if (val > 0.05f) {
        return new Block(Blocks.COAL);
      } else {
        return new Block(Blocks.DIAMOND);
      }
    }
  }
}
class Button {
  private PImage icon, dicon, oicon;
  public int x, y, w, h;
  public int rounding = 10;
  public int pressTime = 0;
  public Boolean beenPressed = false;

  public String iconText = "";
  private int fill, textColor;

  public Boolean centered = true;
  public Boolean side = true;
  public int dark = 40;

  private Button(int x, int y, int w, int h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }

  Button(int x, int y, int w, int h, PImage icon) {
    this(x, y, w, h);
    oicon = icon;
    // dicon is a darked version of the icon, made beforehand in the constructor to increase run speed.
    dicon = createImage(w, h, ARGB);
    formatIcon(icon, true);
  }

  Button(int x, int y, int w, int h, int fill, int textColor, String text) {
    this(x, y, w, h);
    this.fill = fill;
    this.iconText = text;
    this.textColor = textColor;
    icon = createImage(w, h, ARGB);
    formatIcon(icon, false);
  }

  // Adds rounded corners to a PImage
  public void formatIcon(PImage icon, Boolean useImage) {
    dicon = createImage(w, h, ARGB);
    icon.resize(w, h);
    icon.format = ARGB;
    dicon.format = ARGB;
    icon.loadPixels();
    dicon.loadPixels();
    if (!useImage) {
      for (int i = 0; i < w*h; i++) {
        icon.pixels[i] = fill;
      }
    }
    // Basic formulas for rounded edges with a modified circle formula.
    for (int i = 0; i <= rounding; i++) {
      for (int j = 0; j <= rounding - sqrt(pow(rounding, 2)-pow(i, 2)); j++) {
        icon.pixels[(rounding - i) * w + j] = color(0, 0);
        icon.pixels[(i + (h-1) - rounding) * w + j] = color(0, 0);
        icon.pixels[(i + (h-1) - rounding) * w + (w-1) - j] = color(0, 0);
        icon.pixels[(rounding - i - 1) * w + w + (w-1) - j] = color(0, 0);
      }
    }
    // Make darker pixels for dicon
    for (int i = 0; i < w*h; i++) {
      dicon.pixels[i] = color(
        red(icon.pixels[i]) - (dark < red(icon.pixels[i]) ? dark : red(icon.pixels[i])),
        green(icon.pixels[i]) - (dark < green(icon.pixels[i]) ? dark : green(icon.pixels[i])),
        blue(icon.pixels[i]) - (dark < blue(icon.pixels[i]) ? dark : blue(icon.pixels[i])),
        alpha(icon.pixels[i])
        );
    }
    icon.updatePixels();
    dicon.updatePixels();

    this.icon = icon;
  }

  public void display() {
    noStroke();
    if (centered) {
      textAlign(CENTER);
    } else {
      if (side) {
        textAlign(LEFT);
      } else {
        textAlign(RIGHT);
      }
    }
    imageMode(CORNER);
    textSize(h/3);
    fill(textColor);
    // If the button is not pressed, don't display dicon, else, display dicon.
    if (pressTime == 0) {
      image(icon, x, y);
      beenPressed = false;
    } else {
      image(dicon, x, y);
      // Lower presstime.
      pressTime--;
      if (pressTime == 0) {
        beenPressed = true;
      }
    }

    if (centered) {
      text(iconText, x+w/2, y+h/2 + (textAscent() + textDescent())/2*.4f);
    } else {
      if (side) {
        text(iconText, x+w/25, y+h/2 + (textAscent() + textDescent())/2*.4f);
      } else {
        text(iconText, x+w-w/25, y+h/2 + (textAscent() + textDescent())/2*.4f);
      }
    }
  }

  // To be used in mousePressed() or mouseReleased()
  // Should take in mouseX and mouseY
  public void checkPress(int x, int y) {
    if (alpha(icon.get(x-this.x, y - this.y)) > 0) {
      //println(true);
      pressTime = (int) (frameRate);
      // return true
    }
    // return false;
  }
}

class Box {
  private int x, y, w, h;
  public int fill, edge;
  public int shift;

  private int rounding;

  Box(int x, int y, int w, int h) {
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
  }

  Box(int x, int y, int w, int h, int fill, int edge, int rounding) {
    this(x, y, w, h);
    this.fill = fill;
    this.shift = fill;
    this.edge = edge;
    this.rounding = rounding;
  }

  // Draw a rounded box.
  public void display() {
    rectMode(CORNER);
    fill(shift);
    if (shift != fill) {
      shift = color(red(shift) + (red(fill)-red(shift)) * .15f, green(shift) + (green(fill)-green(shift)) * .15f, blue(shift) + (blue(fill)-blue(shift)) * .15f);
      if (abs(red(fill)-red(shift)) + abs(green(fill)-green(shift)) + abs(blue(fill)-blue(shift)) < 15) {
        shift = fill;
      }
    }
    stroke(edge);
    rect(x, y, w, h, rounding);
  }
}

class TextBox {
  public int x, y, w, h;
  private Box background;
  private int textSize;

  private int placeCounter = 0;
  private int maxChar;

  private int textColor;
  private Boolean selected = false;

  public int enterLines = 0;
  public int textLines = 1;
  private float textLen = 0;

  public String text = "";
  public String preview = "";
  public int rounding = 0;
  public Boolean displayCounter = false;
  public int xBorder, yBorder;

  private int point;
  public int addedChars = 0;

  TextBox(int textSize, int x, int y, int w, int h, int inside, int border, int rounding) {
    background = new Box(x, y, w, h, inside, border, rounding);
    this.textSize = textSize;
    this.x = x;
    this.y = y;
    this.w = w;
    this.h = h;
    xBorder = w/10;
    yBorder = h/10;
  }
  TextBox(int maxChar, int textSize, int x, int y, int w, int h, int inside, int border, int textColor, int rounding) {
    this(textSize, x, y, w, h, inside, border, rounding);
    this.maxChar = maxChar;
    this.textColor = textColor;
  }

  public void display() {
    // Set info
    textSize(textSize);
    background.display();

    // Blinking cursor
    placeCounter = (int)((placeCounter + 1) % (frameRate));
    String place = placeCounter > frameRate/2 ? "" : "|";

    // Don't display cursor if not selected.
    if (!selected) {
      place = "";
    }

    // If theres no text, display the preview text or nothing.
    if (text.equals("") && !selected) {
      fill(color(red(textColor), green(textColor), blue(textColor), 100));
      text(preview, x+xBorder/2, y+yBorder/2, w-xBorder, h-yBorder);
    } else { // If there is text, display it.
      fill(textColor);
      text(text, x+xBorder/2, y+yBorder/2, w-xBorder, h-yBorder);
      // Display cursor at end of text. (This was a lot of math and testing, currently fixed: 19 Major Oddities over 12 Hours)
      // Hopefully that's all it takes.
      text(place, x+xBorder/2 + textLen, y+yBorder/2 + (textAscent() + textDescent()) * 1.275f * (textLines-1), w, h-yBorder);
    }

    // If displayCounter is true, show the total number of letters the user can use, and how many they have used.
    if (displayCounter) {
      textSize(textSize-14);
      String textCounter = (text.length() + addedChars) + "/" + maxChar;
      text(textCounter, x+w - textWidth(textCounter) - xBorder/2, y+h - yBorder/2);
    }
  }

  public void updateCursor() {
    // Updates the cursor position.
    textLines = getTextLines(text);
    textLen = getTextLength(text);
  }

  // Gets the length of the last line of the wrapped string.
  public float getTextLength(String str) {
    return getTextHelper(str, true);
  }

  // Gets the number of lines in the wrapped string.
  public int getTextLines(String str) {
    int numLines = 1;

    String[] e = str.split("\n");
    for (int i = 0; i < e.length; i++) {
      numLines += (int) getTextHelper(e[i], false);
    }
    return numLines + enterLines;
  }

  // Returns text information
  private float getTextHelper(String str, Boolean getLength) {
    // If the string ends with newLine or there is no string, textLength is equal to zero.
    if (getLength && str.endsWith("\n") || str.length() == 0) {
      return 0;
    }
    String[] e = str.split("\n");
    String[] s = e[e.length-1].split(" ");
    float currLen = 0;

    textSize(textSize);
    int numLines = 0;
    int spaceCount = 1;
    if (e[e.length-1].length() > 0 && (e[e.length-1].charAt(0) != ' ')) {
      spaceCount++;
      // Counts the number of groups of spaces to create a space array to account for them when .split() is used.
    }
    for (int i = 0; i<e[e.length-1].length(); i++) {
      // Count last group of spaces.
      if (e[e.length-1].charAt(i) == ' ' && i+1 < e[e.length-1].length() && e[e.length-1].charAt(i+1) != ' ') {
        spaceCount++;
      }
    }

    // Count the number of spaces in each group of spaces.
    int[] spaces = new int[spaceCount];
    for (int i = 0; i<spaces.length; i++) {
      spaces[i] = 0;
    }
    spaceCount = 0;
    if (e[e.length-1].length() > 0 && e[e.length-1].charAt(0) != ' ') {
      spaceCount++;
    }

    for (int i = 0; i<e[e.length-1].length(); i++) {
      if (e[e.length-1].charAt(i) == ' ') {
        spaces[spaceCount]++;
      }
      if (e[e.length-1].charAt(i) == ' ' && i+1 < e[e.length-1].length() && e[e.length-1].charAt(i+1) != ' ') {
        spaceCount++;
      }
    }

    // Debugging info.
    // println("Space Groups: " + spaceCount);
    // for(int i = 0; i<spaces.length; i++){
    //   print(spaces[i] + " ");
    // }
    // println("");

    // Add the length of the first group of spaces.
    for (int k = 0; k<spaces[0]; k++) {
      currLen += textWidth(" ");
      if (currLen > w-xBorder) {
        numLines++;
        currLen = 0;
        break;
      }
    }

    // Begin checking rest of text.
    for (int j = 1; j<spaces.length; j++) {
      // Account for .split() messing with groups of spaces.
      int upCount = 0;
      for (int k = 0; k<j; k++) {
        if (spaces[k] > 1) {
          upCount += spaces[k] -1;
        }
      }
      if (spaces[0] > 0) {
        upCount++;
      }

      // Add length of words one by one.
      float temp = currLen;
      currLen += textWidth(s[j-1 + upCount]);
      // If it's greater than what can fit, it's the next line.
      if (currLen > w-xBorder) {
        currLen = textWidth(s[j-1 + upCount]);
        numLines++;
        // If it's still greater, the word is longer than a line, and is wrapping by itself.
        if (currLen > w-xBorder) {
          if (j-1+upCount != 0) {
            float t = 0;
            for (int k = 0; k < s[j-1 + upCount].length(); k++) {
              t += textWidth(s[j-1 + upCount].charAt(k));
            }
            if (t < w-xBorder) {
              numLines--;
            }
          } else {
            numLines--;
          }
          // numLines--;
          currLen = 0;
          // Begin counting from the beginning of the word, but by letter (this is how they wrap).
          for (int k = 0; k < s[j-1 + upCount].length(); k++) {
            currLen += textWidth(s[j-1 + upCount].charAt(k));
            if (currLen > w-xBorder) {
              currLen = textWidth(s[j-1 + upCount].charAt(k));
              numLines++;
            }
          }
        }
      }

      for (int k = 0; k<spaces[j]; k++) {
        // Add length of space groups.
        currLen += textWidth(" ");
        if (currLen > w-xBorder) {
          numLines++;
          currLen = 0;
          break;
        }
      }
    }

    // Return current information.
    if (getLength) {
      return currLen;
    }
    return numLines;
  }

  public void checkKeyPress(int key) {
    textSize(textSize);
    // Don't take in key if the box isn't selected.
    if (selected) {
      // Check if it's on the keyboard and not special, as well as if the amount of text does not surpass maxChar.
      if ((key >= 32 && key <= 176) && text.length() + addedChars < maxChar) {
        // If the text cannot fit in the box, don't put it in.
        if ((getTextLines(text + (char) key)) > round((h-yBorder) / ((textAscent() + textDescent()) * 1.275f))) {
          // println("first went off");
          return;
        }
        // Otherwise, add it to text.
        text += (char) key;
      }
      // Backspace function
      if (key == 8 && text.length() > 0) {
        if (text.endsWith("\n")) {
          // This is done so all of "\n" gets removed
          text = text.substring(0, text.length()-1);
          enterLines--;
        } else if (text.endsWith(" ")) {
          float temp=textLen;
          while (textLen == temp) {
            text = text.substring(0, text.length()-1);
            updateCursor();
          }
        } else {
          text = text.substring(0, text.length()-1);
        }
      }
      // Checks if enter should be allowed at a given point.
      if (key == 10  && text.length() + addedChars < maxChar && (getTextLines(text + (char) key)) + 1 <= round((h-yBorder) / ((textAscent() + textDescent()) * 1.275f))) {
        text += "\n";
        enterLines++;
      }
    }
    // Update cursor position.
    updateCursor();
  }

  public void checkMousePress(int x, int y) {
    // Checks if the mouse is in the box.
    // To be used in mousePressed() or mouseReleased().
    if (x >= this.x && x <= this.x + this.w && y >= this.y && y <= this.y + this.h) {
      // setLine(x, y);
      // insertAtPoint('-');
      selected = true;
      return;
    }
    selected = false;
  }

  // Had an idea for being able to edit any part. Didn't pan out.

  // public void setLine(int mX, int mY){
  //   if(text.length() > 0){
  //     textSize(textSize);
  //     int posY = mY - y + yBorder/2;
  //     stroke(255);
  //     line(0, y + posY, width, y + posY);
  //     int mLine = round(posY / ((textAscent() + textDescent()) * 1.55));
  //     int mLength = mX - x - xBorder/2;
  //     updateCursor();
  //     for(int i = 0; i<text.length(); i++){
  //       Boolean onLine = false;
  //       if(mLine == getTextLines(text.substring(0, i))){
  //         onLine = true;
  //         Boolean noEnter = false;
  //         float temp1 = getTextLength(text.substring(0, i));
  //         float temp2 = getTextLength(text.substring(0, i + 1 < text.length() ? i+1 : text.length()));
  //         if(temp1 + (temp2-temp1)/2 > mLength){
  //           // println(text.charAt(i-1 > 0 ? i-1 : 0));
  //           point = i > 0 ? i : 0;
  //           return;
  //         }
  //       }
  //       if(onLine){
  //         point = text.length();
  //         return;
  //       }
  //     }
  //   }
  //   println(-1);
  //   point = -1;
  //   println("");
  // }

  // public void insertAtPoint(char c){
  //   if(point == -1){
  //     text = "" + c;
  //     return;
  //   }
  //   text = text.substring(0, point) + c + text.substring(point, text.length());
  // }
}


  public void settings() { size(1000, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Minecraft2D" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
